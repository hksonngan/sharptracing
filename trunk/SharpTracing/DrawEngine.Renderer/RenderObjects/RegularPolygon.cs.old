using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using DrawEngine.Renderer.BasicStructures;
using DrawEngine.Renderer.Mathematics.Algebra;
using DrawEngine.Renderer.Algebra;
using System.ComponentModel;

namespace DrawEngine.Renderer.RenderObjects {
    public class RegularPolygon : Primitive, ITransformable3D, IPreprocess {
        private float d;
        private int verticesCount;
        private Vector3D normal;
        private List<Point3D> vertices = new List<Point3D>();
        public RegularPolygon()
            : this(Point3D.Zero, Vector3D.UnitY, 5, 20f) {

        }
        public RegularPolygon(Point3D center, Vector3D normal, int numVertices, float radius) {
            this.VerticesCount = numVertices;
            this.Radius = radius;
            this.Normal = normal;
            this.Center = center;
        }

        public Point3D Center {
            get { return base.center; }
            set {
                base.center = value;
                this.Preprocess();
            }
        }

        [TypeConverter(typeof(ExpandableObjectConverter))]
        public List<Point3D> Vertices {
            get { return this.vertices; }
        }
        public Vector3D Normal {
            get { return this.normal; }
            set {
                this.normal = value.Normalized;
                this.Preprocess();
            }
        }
        public int VerticesCount {
            get { return this.verticesCount; }
            set {
                if(value < 3) {
                    throw new ArgumentOutOfRangeException("VerticesCount", "The number of vertices must be greater than 3!");
                }
                this.verticesCount = value;
                this.Preprocess();
            }
        }
        private float radius;
        public float Radius {
            get { return this.radius; }
            set {
                if(value <= 0) {
                    throw new ArgumentOutOfRangeException("Radius", "Radius must be greater than zero!");
                }
                this.radius = value;
                this.Preprocess();
            }
        }
        public override bool IsOverlap(BoundBox boundBox) {
            throw new NotImplementedException();
        }

        public override bool FindIntersection(Ray ray, out Intersection intersect) {
            intersect = new Intersection();
            //t = -(N • Ro + D) / (N • Rd)	
            //Vector3D origin = ray.Origin.ToVector3D();
            float NRd = this.normal * ray.Direction;
            if(NRd == 0.0f) {
                return false;
            }
            float t = -(this.normal * ray.Origin.ToVector3D() + this.d) / NRd;
            if(t < 0.01f) {
                return false;
            }
            intersect.Normal = this.normal;
            intersect.HitPoint = ray.Origin + (t * ray.Direction);
            intersect.HitPrimitive = this;
            intersect.TMin = t;
            return PointIsInPolygon(intersect.HitPoint);
        }
        private const double maxAngle = ((2.0 * Math.PI) * 0.9999);
        /// <summary>
        /// Determines if a point is in the polygon
        /// </summary>
        /// <param name="point">The point to test, in object coordinates</param>
        /// <returns>True if point is inside, false otherwise</returns>
        private bool PointIsInPolygon(Point3D point) {
            double angle = 0.0;
            Vector3D a, b;
            for(int i = 0; i < this.verticesCount; i++) {
                a = this.Vertices[i] - point;
                b = this.Vertices[(i + 1) % this.Vertices.Count] - point;
                double acos = Math.Acos(a.Normalized * b.Normalized);
                angle += Double.IsNaN(acos) ? 0 : acos;
            }

            if(angle >= maxAngle)
                return true;
            return false;
        }

        public override bool IsInside(Point3D point) {
            throw new NotImplementedException();
        }

        public override Vector3D NormalOnPoint(Point3D pointInPrimitive) {
            return this.normal;
        }

        #region IPreprocess Members

        public void Preprocess() {
            if(this.verticesCount >= 3) {

                this.d = -(normal.X * center.X) - (normal.Y * center.Y) - (normal.Z * center.Z);
                Vector3D inPlaneVector;
                Vector3D.Orthonormalize(this.normal, out inPlaneVector);
                Point3D initialPoint = center + this.radius * inPlaneVector;
                this.vertices.Clear();
                this.vertices.Add(initialPoint);
                float angleToRotation = (float)(2 * Math.PI) / this.verticesCount;
                for(int i = 1; i < this.verticesCount; i++) {
                    //Point3D nextPoint = this.vertices[i - 1];
                    //nextPoint.Rotate(angleToRotation, this.normal);
                    inPlaneVector.Rotate(angleToRotation, this.normal);
                    initialPoint = center + this.radius * inPlaneVector;
                    this.vertices.Add(initialPoint);
                }
            }
        }

        #endregion

        #region ITransformable3D Members

        public void Rotate(float angle, Vector3D axis) {
            this.center.Rotate(angle, axis);
            this.Preprocess();
        }
        public void RotateAxisX(float angle) {
            this.Rotate(angle, Vector3D.UnitX);
        }
        public void RotateAxisY(float angle) {
            this.Rotate(angle, Vector3D.UnitY);
        }
        public void RotateAxisZ(float angle) {
            this.Rotate(angle, Vector3D.UnitZ);
        }
        public void Scale(float factor) {
            this.Radius = radius * factor;
        }
        public void Translate(float tx, float ty, float tz) {
            this.center.Translate(tx, ty, tz);
            this.Preprocess();
        }
        public void Translate(Vector3D translateVector) {
            this.Translate(translateVector.X, translateVector.Y, translateVector.Z);
        }
        #endregion
    }
}
